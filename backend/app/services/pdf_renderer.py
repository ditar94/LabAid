"""PDF rendering for compliance reports using fpdf2."""

from datetime import datetime
from zoneinfo import ZoneInfo

from fpdf import FPDF


def _format_local_time(tz: str | None = None) -> str:
    """Format current time in user's timezone, falling back to UTC."""
    if tz:
        try:
            now = datetime.now(ZoneInfo(tz))
            return now.strftime("%Y-%m-%d %H:%M %Z")
        except Exception:
            pass
    return datetime.now().strftime("%Y-%m-%d %H:%M")


def _safe(text: str) -> str:
    """Sanitize text for core Helvetica (latin-1). Replace common non-latin-1 chars."""
    return (
        text
        .replace("\u2014", "--")   # em dash
        .replace("\u2013", "-")    # en dash
        .replace("\u2018", "'")    # left single quote
        .replace("\u2019", "'")    # right single quote
        .replace("\u201c", '"')    # left double quote
        .replace("\u201d", '"')    # right double quote
        .replace("\u2026", "...")  # ellipsis
        .replace("\u2022", "-")    # bullet
        .encode("latin-1", errors="replace")
        .decode("latin-1")
    )


class LabAidPDF(FPDF):
    """Base PDF class with branded header and footer."""

    def __init__(self, title: str, lab_name: str, pulled_by: str = "",
                 subtitle: str = "", tz: str | None = None):
        super().__init__(orientation="P", unit="mm", format="A4")
        self.report_title = title
        self.lab_name = lab_name
        self.pulled_by = pulled_by
        self.subtitle = subtitle
        self.generated_at = _format_local_time(tz)
        self.set_auto_page_break(auto=True, margin=20)

    def header(self):
        self.set_font("Helvetica", "B", 14)
        self.cell(0, 8, self.report_title, new_x="LMARGIN", new_y="NEXT")
        self.set_font("Helvetica", "", 9)
        self.set_text_color(100, 100, 100)
        parts = [f"Lab: {self.lab_name}"]
        if self.subtitle:
            parts.append(self.subtitle)
        if self.pulled_by:
            parts.append(f"Pulled by: {self.pulled_by}")
        parts.append(f"Generated: {self.generated_at}")
        self.cell(0, 5, "  |  ".join(parts), new_x="LMARGIN", new_y="NEXT")
        self.set_text_color(0, 0, 0)
        self.ln(3)

    def footer(self):
        self.set_y(-15)
        self.set_font("Helvetica", "I", 8)
        self.set_text_color(130, 130, 130)
        self.cell(0, 10, f"Page {self.page_no()}/{{nb}}  --  Electronically generated by LabAid. Do not alter.", align="C")

    def _table_header(self, columns: list[tuple[str, int]]):
        self.set_font("Helvetica", "B", 8)
        self.set_fill_color(240, 240, 245)
        for col_name, col_width in columns:
            self.cell(col_width, 7, col_name, border=1, fill=True)
        self.ln()

    def _table_row(self, values: list[str], widths: list[int]):
        self.set_font("Helvetica", "", 7)
        safe_vals = [_safe(str(v)) for v in values]
        max_h = 7
        line_heights = []
        for val, w in zip(safe_vals, widths):
            # Count explicit newlines and width-based wrapping per sub-line
            sub_lines = val.split("\n") if "\n" in val else [val]
            total_lines = 0
            for sub in sub_lines:
                text_w = self.get_string_width(sub)
                total_lines += max(1, int(text_w / (w - 2)) + 1)
            line_heights.append(total_lines * 4)
        row_h = max(max_h, max(line_heights))

        if self.get_y() + row_h > self.h - 20:
            self.add_page()

        y_start = self.get_y()
        x_start = self.get_x()
        for i, (val, w) in enumerate(zip(safe_vals, widths)):
            x = x_start + sum(widths[:i])
            self.set_xy(x, y_start)
            self.multi_cell(w, 4, val, border=1, new_x="RIGHT", new_y="TOP", max_line_height=row_h)
        self.set_y(y_start + row_h)

    def _section_header(self, title: str):
        """Render a section title (e.g., antibody name) as a bold row."""
        if self.get_y() + 14 > self.h - 20:
            self.add_page()
        self.ln(4)
        self.set_font("Helvetica", "B", 10)
        self.set_text_color(50, 50, 50)
        self.cell(0, 7, _safe(title), new_x="LMARGIN", new_y="NEXT")
        self.set_text_color(0, 0, 0)
        self.ln(1)


def _render_table(title: str, lab_name: str, pulled_by: str,
                  columns: list[tuple[str, int]], data: list[dict],
                  row_fn, subtitle: str = "", tz: str | None = None) -> bytes:
    """Shared helper to render a flat table PDF."""
    pdf = LabAidPDF(title, lab_name, pulled_by, subtitle=subtitle, tz=tz)
    pdf.alias_nb_pages()
    pdf.add_page()
    pdf._table_header(columns)
    widths = [c[1] for c in columns]
    for row in data:
        pdf._table_row(row_fn(row), widths)
    return bytes(pdf.output())


def _render_grouped_table(title: str, lab_name: str, pulled_by: str,
                          columns: list[tuple[str, int]], data: list[dict],
                          row_fn, group_key: str = "antibody_full",
                          tz: str | None = None) -> bytes:
    """Render a PDF with data grouped by antibody, each group as its own table."""
    pdf = LabAidPDF(title, lab_name, pulled_by, tz=tz)
    pdf.alias_nb_pages()
    pdf.add_page()
    widths = [c[1] for c in columns]

    groups: dict[str, list[dict]] = {}
    for row in data:
        key = row.get(group_key) or "Unknown"
        groups.setdefault(key, []).append(row)

    for group_name, group_rows in groups.items():
        pdf._section_header(group_name)
        pdf._table_header(columns)
        for row in group_rows:
            pdf._table_row(row_fn(row), widths)

    return bytes(pdf.output())


def render_lot_activity_pdf(data: list[dict], lab_name: str,
                            pulled_by: str = "", tz: str | None = None) -> bytes:
    columns = [
        ("Lot #", 24), ("Expiration", 19), ("Received", 19),
        ("Received By", 28), ("QC Doc", 13), ("QC Approved", 19),
        ("QC Approved By", 28), ("First Opened", 20), ("Last Opened", 20),
    ]
    return _render_grouped_table(
        "Lot Activity Report", lab_name, pulled_by, columns, data,
        lambda r: [
            r["lot_number"], r["expiration"], r["received"],
            r["received_by"], r["qc_doc"], r["qc_approved"],
            r["qc_approved_by"], r["first_opened"], r["last_opened"],
        ],
        tz=tz,
    )


def render_usage_pdf(data: list[dict], lab_name: str,
                     pulled_by: str = "", tz: str | None = None) -> bytes:
    columns = [
        ("Lot #", 24), ("Expiration", 20), ("Received", 20),
        ("Vials Rcvd", 18), ("Vials Used", 18),
        ("First Opened", 22), ("Last Opened", 22),
        ("Avg/Wk", 18), ("Status", 28),
    ]
    pdf = LabAidPDF("Usage by Lot", lab_name, pulled_by, tz=tz)
    pdf.alias_nb_pages()
    pdf.add_page()
    widths = [c[1] for c in columns]

    groups: dict[str, list[dict]] = {}
    for row in data:
        key = row.get("antibody_full") or "Unknown"
        groups.setdefault(key, []).append(row)

    for group_name, group_rows in groups.items():
        pdf._section_header(group_name)
        pdf._table_header(columns)
        for row in group_rows:
            pdf._table_row([
                row["lot_number"], row["expiration"], row["received"],
                str(row["vials_received"]), str(row["vials_consumed"]),
                row["first_opened"], row["last_opened"],
                row["avg_week"], row["status"],
            ], widths)

        # Antibody summary line
        ab_avg = group_rows[0].get("ab_avg_week", "")
        total_consumed = sum(r["vials_consumed"] for r in group_rows)
        total_received = sum(r["vials_received"] for r in group_rows)
        if ab_avg:
            pdf.set_font("Helvetica", "I", 7)
            pdf.set_text_color(100, 100, 100)
            pdf.cell(0, 5, _safe(
                f"Antibody total: {total_consumed}/{total_received} vials consumed  |  "
                f"Weighted avg: {ab_avg} vials/week"
            ), new_x="LMARGIN", new_y="NEXT")
            pdf.set_text_color(0, 0, 0)

    return bytes(pdf.output())


def render_usage_trend_pdf(data: list[dict], lab_name: str,
                           pulled_by: str = "", tz: str | None = None) -> bytes:
    """Render usage trend grouped by antibody, with a total row per group."""
    columns = [
        ("Month", 45), ("Vials Opened", 35), ("Lots Active", 35),
        ("Weeks", 35), ("Avg/Wk", 40),
    ]
    pdf = LabAidPDF("Usage by Month", lab_name, pulled_by, tz=tz)
    pdf.alias_nb_pages()
    pdf.add_page()
    widths = [c[1] for c in columns]

    groups: dict[str, list[dict]] = {}
    for row in data:
        key = row.get("antibody_full") or "Unknown"
        groups.setdefault(key, []).append(row)

    for group_name, group_rows in groups.items():
        pdf._section_header(group_name)
        pdf._table_header(columns)
        for row in group_rows:
            pdf._table_row([
                row["month_label"], str(row["vials_opened"]),
                str(row["lots_active"]), row["weeks"], row["avg_week"],
            ], widths)

        # Total row
        total_vials = group_rows[0].get("total_vials", 0)
        total_weeks = group_rows[0].get("total_weeks", "")
        total_avg = group_rows[0].get("total_avg_week", "")
        if total_vials:
            pdf.set_font("Helvetica", "B", 7)
            pdf.set_fill_color(245, 245, 250)
            pdf._table_row([
                "Total", str(total_vials), "", total_weeks, total_avg,
            ], widths)

    return bytes(pdf.output())


def render_admin_activity_pdf(data: list[dict], lab_name: str,
                               pulled_by: str = "", tz: str | None = None) -> bytes:
    columns = [
        ("Timestamp", 30), ("Action", 30), ("Performed By", 30),
        ("Target", 46), ("Details", 54),
    ]
    return _render_table(
        "Admin Activity Report", lab_name, pulled_by, columns, data,
        lambda r: [
            r["timestamp"][:19], r["action"], r["performed_by"],
            r["target"], r["details"],
        ],
        tz=tz,
    )


def render_audit_trail_pdf(data: list[dict], lab_name: str,
                            pulled_by: str = "", tz: str | None = None) -> bytes:
    columns = [
        ("Timestamp", 28), ("User", 24), ("Action", 24),
        ("Entity Type", 18), ("Entity", 48), ("Note", 36), ("Support", 12),
    ]
    return _render_table(
        "Audit Trail Report", lab_name, pulled_by, columns, data,
        lambda r: [
            r["timestamp"][:19], r["user"], r["action"],
            r["entity_type"], r["entity"], r["note"], r["support"],
        ],
        tz=tz,
    )


def render_cocktail_lot_pdf(data: list[dict], lab_name: str,
                             pulled_by: str = "", tz: str | None = None) -> bytes:
    columns = [
        ("Lot #", 20), ("Prepared", 18), ("Expires", 18),
        ("QC", 12), ("QC By", 20), ("Renewals", 12),
        ("Tests", 10), ("Status", 14), ("Created By", 20), ("Components", 46),
    ]
    return _render_grouped_table(
        "Cocktail Lot Report", lab_name, pulled_by, columns, data,
        lambda r: [
            r["lot_number"], r["preparation_date"], r["expiration_date"],
            r["qc_status"], r["qc_approved_by"], str(r["renewal_count"]),
            str(r.get("test_count", "")),
            r["status"], r["created_by"], r["components"],
        ],
        group_key="recipe_name",
        tz=tz,
    )
