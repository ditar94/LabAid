"""PDF rendering for compliance reports using fpdf2."""

from datetime import datetime

from fpdf import FPDF


def _safe(text: str) -> str:
    """Sanitize text for core Helvetica (latin-1). Replace common non-latin-1 chars."""
    return (
        text
        .replace("\u2014", "--")   # em dash
        .replace("\u2013", "-")    # en dash
        .replace("\u2018", "'")    # left single quote
        .replace("\u2019", "'")    # right single quote
        .replace("\u201c", '"')    # left double quote
        .replace("\u201d", '"')    # right double quote
        .replace("\u2026", "...")  # ellipsis
        .replace("\u2022", "-")    # bullet
        .encode("latin-1", errors="replace")
        .decode("latin-1")
    )


class LabAidPDF(FPDF):
    """Base PDF class with branded header and footer."""

    def __init__(self, title: str, lab_name: str, pulled_by: str = "",
                 subtitle: str = ""):
        super().__init__(orientation="L", unit="mm", format="A4")
        self.report_title = title
        self.lab_name = lab_name
        self.pulled_by = pulled_by
        self.subtitle = subtitle
        self.generated_at = datetime.now().strftime("%Y-%m-%d %H:%M")
        self.set_auto_page_break(auto=True, margin=20)

    def header(self):
        self.set_font("Helvetica", "B", 14)
        self.cell(0, 8, self.report_title, new_x="LMARGIN", new_y="NEXT")
        self.set_font("Helvetica", "", 9)
        self.set_text_color(100, 100, 100)
        parts = [f"Lab: {self.lab_name}"]
        if self.subtitle:
            parts.append(self.subtitle)
        if self.pulled_by:
            parts.append(f"Pulled by: {self.pulled_by}")
        parts.append(f"Generated: {self.generated_at}")
        self.cell(0, 5, "  |  ".join(parts), new_x="LMARGIN", new_y="NEXT")
        self.set_text_color(0, 0, 0)
        self.ln(3)

    def footer(self):
        self.set_y(-15)
        self.set_font("Helvetica", "I", 8)
        self.set_text_color(130, 130, 130)
        self.cell(0, 10, f"Page {self.page_no()}/{{nb}}  --  Electronically generated by LabAid. Do not alter.", align="C")

    def _table_header(self, columns: list[tuple[str, int]]):
        self.set_font("Helvetica", "B", 8)
        self.set_fill_color(240, 240, 245)
        for col_name, col_width in columns:
            self.cell(col_width, 7, col_name, border=1, fill=True)
        self.ln()

    def _table_row(self, values: list[str], widths: list[int]):
        self.set_font("Helvetica", "", 7)
        safe_vals = [_safe(str(v)) for v in values]
        max_h = 7
        line_heights = []
        for val, w in zip(safe_vals, widths):
            text_w = self.get_string_width(val)
            lines = max(1, int(text_w / (w - 2)) + 1)
            line_heights.append(lines * 4)
        row_h = max(max_h, max(line_heights))

        if self.get_y() + row_h > self.h - 20:
            self.add_page()

        y_start = self.get_y()
        x_start = self.get_x()
        for i, (val, w) in enumerate(zip(safe_vals, widths)):
            x = x_start + sum(widths[:i])
            self.set_xy(x, y_start)
            self.multi_cell(w, 4, val, border=1, new_x="RIGHT", new_y="TOP", max_line_height=row_h)
        self.set_y(y_start + row_h)

    def _section_header(self, title: str):
        """Render a section title (e.g., antibody name) as a bold row."""
        if self.get_y() + 14 > self.h - 20:
            self.add_page()
        self.ln(4)
        self.set_font("Helvetica", "B", 10)
        self.set_text_color(50, 50, 50)
        self.cell(0, 7, _safe(title), new_x="LMARGIN", new_y="NEXT")
        self.set_text_color(0, 0, 0)
        self.ln(1)


def _render_table(title: str, lab_name: str, pulled_by: str,
                  columns: list[tuple[str, int]], data: list[dict],
                  row_fn, subtitle: str = "") -> bytes:
    """Shared helper to render a flat table PDF."""
    pdf = LabAidPDF(title, lab_name, pulled_by, subtitle=subtitle)
    pdf.alias_nb_pages()
    pdf.add_page()
    pdf._table_header(columns)
    widths = [c[1] for c in columns]
    for row in data:
        pdf._table_row(row_fn(row), widths)
    return bytes(pdf.output())


def _render_grouped_table(title: str, lab_name: str, pulled_by: str,
                          columns: list[tuple[str, int]], data: list[dict],
                          row_fn, group_key: str = "antibody_full") -> bytes:
    """Render a PDF with data grouped by antibody, each group as its own table."""
    pdf = LabAidPDF(title, lab_name, pulled_by)
    pdf.alias_nb_pages()
    pdf.add_page()
    widths = [c[1] for c in columns]

    groups: dict[str, list[dict]] = {}
    for row in data:
        key = row.get(group_key) or "Unknown"
        groups.setdefault(key, []).append(row)

    for group_name, group_rows in groups.items():
        pdf._section_header(group_name)
        pdf._table_header(columns)
        for row in group_rows:
            pdf._table_row(row_fn(row), widths)

    return bytes(pdf.output())


def render_lot_activity_pdf(data: list[dict], lab_name: str,
                            pulled_by: str = "") -> bytes:
    columns = [
        ("Lot #", 30), ("Expiration", 24), ("Received", 24),
        ("Received By", 35), ("QC Doc", 16), ("QC Approved", 24),
        ("QC Approved By", 35), ("First Opened", 24), ("Last Opened", 24),
    ]
    return _render_grouped_table(
        "Lot Activity Report", lab_name, pulled_by, columns, data,
        lambda r: [
            r["lot_number"], r["expiration"], r["received"],
            r["received_by"], r["qc_doc"], r["qc_approved"],
            r["qc_approved_by"], r["first_opened"], r["last_opened"],
        ],
    )


def render_usage_pdf(data: list[dict], lab_name: str,
                     pulled_by: str = "") -> bytes:
    columns = [
        ("Lot #", 30), ("Expiration", 24), ("Received", 24),
        ("Received", 24), ("Consumed", 22),
        ("First Opened", 26), ("Last Opened", 26),
        ("Avg/Wk", 20), ("Status", 24),
    ]
    pdf = LabAidPDF("Usage Report", lab_name, pulled_by)
    pdf.alias_nb_pages()
    pdf.add_page()
    widths = [c[1] for c in columns]

    groups: dict[str, list[dict]] = {}
    for row in data:
        key = row.get("antibody_full") or "Unknown"
        groups.setdefault(key, []).append(row)

    for group_name, group_rows in groups.items():
        pdf._section_header(group_name)
        pdf._table_header(columns)
        for row in group_rows:
            pdf._table_row([
                row["lot_number"], row["expiration"], row["received"],
                str(row["vials_received"]), str(row["vials_consumed"]),
                row["first_opened"], row["last_opened"],
                row["avg_week"], row["status"],
            ], widths)

        # Antibody summary line
        ab_avg = group_rows[0].get("ab_avg_week", "")
        total_consumed = sum(r["vials_consumed"] for r in group_rows)
        total_received = sum(r["vials_received"] for r in group_rows)
        if ab_avg:
            pdf.set_font("Helvetica", "I", 7)
            pdf.set_text_color(100, 100, 100)
            pdf.cell(0, 5, _safe(
                f"Antibody total: {total_consumed}/{total_received} vials consumed  |  "
                f"Weighted avg: {ab_avg} vials/week"
            ), new_x="LMARGIN", new_y="NEXT")
            pdf.set_text_color(0, 0, 0)

    return bytes(pdf.output())


def render_admin_activity_pdf(data: list[dict], lab_name: str, pulled_by: str = "") -> bytes:
    columns = [
        ("Timestamp", 42), ("Action", 40), ("Performed By", 40),
        ("Target", 60), ("Details", 75),
    ]
    return _render_table(
        "Admin Activity Report", lab_name, pulled_by, columns, data,
        lambda r: [
            r["timestamp"][:19], r["action"], r["performed_by"],
            r["target"], r["details"],
        ],
    )


def render_audit_trail_pdf(data: list[dict], lab_name: str, pulled_by: str = "") -> bytes:
    columns = [
        ("Timestamp", 42), ("User", 35), ("Action", 35),
        ("Entity Type", 25), ("Entity", 70), ("Note", 55), ("Support", 15),
    ]
    return _render_table(
        "Audit Trail Report", lab_name, pulled_by, columns, data,
        lambda r: [
            r["timestamp"][:19], r["user"], r["action"],
            r["entity_type"], r["entity"], r["note"], r["support"],
        ],
    )
